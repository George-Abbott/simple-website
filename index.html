<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #333;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 200;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Health: <span id="health">100</span></div>
            <div>Wave: <span id="wave">1</span></div>
        </div>
        <div id="gameOver">
            <div>Game Over!</div>
            <div>Final Score: <span id="finalScore">0</span></div>
            <div style="margin-top: 10px; font-size: 16px;">Press SPACE to restart</div>
        </div>
        <div id="instructions">
            WASD: Move | Mouse: Aim | Click: Shoot | SPACE: Restart (when dead)
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        const game = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 12,
                health: 100,
                maxHealth: 100,
                speed: 4,
                angle: 0,
                shootCooldown: 0,
                maxShootCooldown: 10
            },
            bullets: [],
            enemies: [],
            particles: [],
            score: 0,
            wave: 1,
            enemiesPerWave: 5,
            enemySpawnTimer: 0,
            enemySpawnRate: 120,
            gameOver: false,
            keys: {},
            mouse: { x: 0, y: 0, isDown: false },
            obstacles: [
                { x: 100, y: 100, width: 100, height: 20 },
                { x: 600, y: 400, width: 20, height: 150 },
                { x: 200, y: 400, width: 150, height: 20 },
                { x: 400, y: 100, width: 20, height: 100 }
            ],
            survivalTime: 0, // Time in frames (60 frames = 1 second)
            difficultyMultiplier: 1 // Base difficulty multiplier
        };
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && game.gameOver) {
                restartGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            game.mouse.isDown = true;
        });
        
        canvas.addEventListener('mouseup', (e) => {
            game.mouse.isDown = false;
        });
        
        canvas.addEventListener('mouseleave', (e) => {
            game.mouse.isDown = false;
        });
        
        // Game objects
        class Bullet {
            constructor(x, y, angle, speed = 8) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.radius = 3;
                this.life = 100;
            }
            
            update() {
                const newX = this.x + this.vx;
                const newY = this.y + this.vy;

                // Check obstacle collisions
                for (let obstacle of game.obstacles) {
                    if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                        .collidesWith(newX, newY, this.radius)) {
                        return false; // Bullet is destroyed
                    }
                }

                this.x = newX;
                this.y = newY;
                this.life--;
                
                return this.life > 0 && 
                       this.x > -10 && this.x < canvas.width + 10 &&
                       this.y > -10 && this.y < canvas.height + 10;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Enemy {
            constructor() {
                // Spawn from random edge
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: // top
                        this.x = Math.random() * canvas.width;
                        this.y = -20;
                        break;
                    case 1: // right
                        this.x = canvas.width + 20;
                        this.y = Math.random() * canvas.height;
                        break;
                    case 2: // bottom
                        this.x = Math.random() * canvas.width;
                        this.y = canvas.height + 20;
                        break;
                    case 3: // left
                        this.x = -20;
                        this.y = Math.random() * canvas.height;
                        break;
                }
                
                // Scale attributes based on survival time
                const minutes = game.survivalTime / (60 * 60); // Convert frames to minutes
                game.difficultyMultiplier = 1 + (minutes * 0.5); // Increase by 50% per minute (up from 20%)

                this.radius = 10 + Math.random() * 8;
                this.speed = (1 + Math.random() * 1.5) * (game.difficultyMultiplier * 0.8); // Slightly reduced speed scaling
                this.health = Math.ceil((2 + Math.floor(game.wave / 2)) * game.difficultyMultiplier * 1.2); // Increased health scaling
                this.maxHealth = this.health;
                this.hue = Math.random() * 60 + 300;
            }
            
            update() {
                // Move toward player
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }

                // Check collision with other enemies
                for (let other of game.enemies) {
                    if (other === this) continue;
                    
                    const enemyDx = this.x - other.x;
                    const enemyDy = this.y - other.y;
                    const enemyDist = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);
                    const minDist = this.radius + other.radius;
                    
                    if (enemyDist < minDist && enemyDist > 0) {
                        // Push enemies apart
                        const pushX = (enemyDx / enemyDist) * (minDist - enemyDist) * 0.5;
                        const pushY = (enemyDy / enemyDist) * (minDist - enemyDist) * 0.5;
                        
                        this.x += pushX;
                        this.y += pushY;
                        other.x -= pushX;
                        other.y -= pushY;
                    }
                }

                // Resolve any obstacle collisions that might have occurred
                let attempts = 0;
                const MAX_ATTEMPTS = 3;
                
                while (attempts < MAX_ATTEMPTS) {
                    let hasCollision = false;
                    for (let obstacle of game.obstacles) {
                        if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                            .resolveCollision(this)) {
                            hasCollision = true;
                        }
                    }
                    if (!hasCollision) break;
                    attempts++;
                }
                
                // Check collision with player
                const playerDist = Math.sqrt(
                    (this.x - game.player.x) ** 2 + 
                    (this.y - game.player.y) ** 2
                );
                
                if (playerDist < this.radius + game.player.radius && playerDist > 0) {
                    game.player.health -= 1;
                    if (game.player.health <= 0) {
                        game.gameOver = true;
                    }
                    
                    // Push enemy away slightly
                    const pushX = (this.x - game.player.x) / playerDist;
                    const pushY = (this.y - game.player.y) / playerDist;
                    this.x += pushX * 10;
                    this.y += pushY * 10;
                }
                
                return this.health > 0;
            }
            
            draw() {
                const healthPercent = this.health / this.maxHealth;
                const intensity = 0.3 + healthPercent * 0.7;
                
                ctx.save();
                ctx.fillStyle = `hsl(${this.hue}, 70%, ${intensity * 50}%)`;
                ctx.shadowColor = `hsl(${this.hue}, 70%, 50%)`;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.radius * 2;
                    const barHeight = 3;
                    const barY = this.y - this.radius - 8;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
                }
                
                ctx.restore();
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    game.score += 10;
                    createParticles(this.x, this.y, this.hue);
                    return true;
                }
                return false;
            }
        }
        
        class Particle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30 + Math.random() * 20;
                this.maxLife = this.life;
                this.hue = hue;
                this.size = Math.random() * 3 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = '#555';
                ctx.shadowColor = '#333';
                ctx.shadowBlur = 5;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.restore();
            }

            collidesWith(x, y, radius) {
                // Find the closest point to the circle within the rectangle
                const closestX = Math.max(this.x, Math.min(x, this.x + this.width));
                const closestY = Math.max(this.y, Math.min(y, this.y + this.height));
                
                // Calculate the distance between the circle's center and this closest point
                const distanceX = x - closestX;
                const distanceY = y - closestY;
                
                // If the distance is less than the circle's radius, an intersection occurs
                const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
                return distanceSquared < (radius * radius);
            }

            resolveCollision(entity) {
                // Find the closest point to the circle within the rectangle
                const closestX = Math.max(this.x, Math.min(entity.x, this.x + this.width));
                const closestY = Math.max(this.y, Math.min(entity.y, this.y + this.height));
                
                // Calculate the distance and direction from the closest point to the circle center
                const dx = entity.x - closestX;
                const dy = entity.y - closestY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < entity.radius && distance > 0) {
                    // Calculate the minimum distance needed to separate the circle from the rectangle
                    const pushDistance = entity.radius - distance;
                    
                    // Normalize the direction and apply the push with a small buffer
                    const pushX = (dx / distance) * (pushDistance + 0.1); // Add small buffer
                    const pushY = (dy / distance) * (pushDistance + 0.1);
                    
                    entity.x += pushX;
                    entity.y += pushY;
                    
                    // Ensure the entity stays within canvas bounds
                    entity.x = Math.min(Math.max(entity.radius, entity.x), canvas.width - entity.radius);
                    entity.y = Math.min(Math.max(entity.radius, entity.y), canvas.height - entity.radius);
                    
                    return true;
                }
                return false;
            }
        }
        
        function createParticles(x, y, hue) {
            for (let i = 0; i < 8; i++) {
                game.particles.push(new Particle(x, y, hue));
            }
        }
        
        function shoot() {
            const angle = Math.atan2(
                game.mouse.y - game.player.y,
                game.mouse.x - game.player.x
            );
            
            game.bullets.push(new Bullet(
                game.player.x + Math.cos(angle) * game.player.radius,
                game.player.y + Math.sin(angle) * game.player.radius,
                angle
            ));
        }
        
        function spawnEnemy() {
            game.enemies.push(new Enemy());
        }
        
        function updatePlayer() {
            if (game.gameOver) return;
            
            let newX = game.player.x;
            let newY = game.player.y;

            // Movement
            if (game.keys['w'] || game.keys['arrowup']) {
                newY = game.player.y - game.player.speed;
            }
            if (game.keys['s'] || game.keys['arrowdown']) {
                newY = game.player.y + game.player.speed;
            }
            if (game.keys['a'] || game.keys['arrowleft']) {
                newX = game.player.x - game.player.speed;
            }
            if (game.keys['d'] || game.keys['arrowright']) {
                newX = game.player.x + game.player.speed;
            }

            // Apply movement within canvas bounds
            game.player.x = Math.min(Math.max(game.player.radius, newX), canvas.width - game.player.radius);
            game.player.y = Math.min(Math.max(game.player.radius, newY), canvas.height - game.player.radius);

            // Resolve any obstacle collisions that might have occurred
            let attempts = 0;
            const MAX_ATTEMPTS = 3;
            
            while (attempts < MAX_ATTEMPTS) {
                let hasCollision = false;
                for (let obstacle of game.obstacles) {
                    if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                        .resolveCollision(game.player)) {
                        hasCollision = true;
                    }
                }
                if (!hasCollision) break;
                attempts++;
            }
            
            // Aim toward mouse
            game.player.angle = Math.atan2(
                game.mouse.y - game.player.y,
                game.mouse.x - game.player.x
            );
        }
        
        function drawPlayer() {
            ctx.save();
            ctx.translate(game.player.x, game.player.y);
            ctx.rotate(game.player.angle);
            
            // Player body
            ctx.fillStyle = game.gameOver ? '#666' : '#00ff88';
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(0, 0, game.player.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Gun barrel
            ctx.fillStyle = '#aaa';
            ctx.fillRect(game.player.radius - 2, -2, 15, 4);
            
            ctx.restore();
        }
        
        function updateGame() {
            if (game.gameOver) return;
            
            // Update survival time and difficulty
            game.survivalTime++;
            
            // Calculate spawn rate based on survival time
            const baseSpawnRate = 120; // Starting spawn rate
            const minutes = game.survivalTime / (60 * 60);
            // More aggressive spawn rate reduction
            game.enemySpawnRate = Math.max(20, Math.floor(baseSpawnRate / (game.difficultyMultiplier * 1.2)));

            // Handle continuous shooting
            if (game.mouse.isDown && game.player.shootCooldown <= 0) {
                shoot();
                game.player.shootCooldown = game.player.maxShootCooldown;
            }
            
            // Update shoot cooldown
            if (game.player.shootCooldown > 0) {
                game.player.shootCooldown--;
            }

            // Spawn enemies
            game.enemySpawnTimer++;
            if (game.enemySpawnTimer >= game.enemySpawnRate) {
                spawnEnemy();
                game.enemySpawnTimer = 0;
                
                // 40% chance to increase wave when an enemy spawns
                if (Math.random() < 0.4) {
                    game.wave++;
                }
            }
            
            // Update bullets
            game.bullets = game.bullets.filter(bullet => {
                const alive = bullet.update();
                
                // Check collision with enemies
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const enemy = game.enemies[i];
                    const dist = Math.sqrt(
                        (bullet.x - enemy.x) ** 2 + 
                        (bullet.y - enemy.y) ** 2
                    );
                    
                    if (dist < bullet.radius + enemy.radius) {
                        if (enemy.takeDamage()) {
                            game.enemies.splice(i, 1);
                        }
                        return false; // Remove bullet
                    }
                }
                
                return alive;
            });
            
            // Update enemies
            game.enemies = game.enemies.filter(enemy => enemy.update());
            
            // Update particles
            game.particles = game.particles.filter(particle => particle.update());
            
            updatePlayer();
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'rgba(17, 17, 17, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw obstacles
            game.obstacles.forEach(obstacle => {
                new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height).draw();
            });
            
            // Draw particles
            game.particles.forEach(particle => particle.draw());
            
            // Draw bullets
            game.bullets.forEach(bullet => bullet.draw());
            
            // Draw enemies
            game.enemies.forEach(enemy => enemy.draw());
            
            // Draw player
            drawPlayer();
            
            // Update UI
            document.getElementById('score').textContent = game.score;
            document.getElementById('health').textContent = Math.max(0, game.player.health);
            document.getElementById('wave').textContent = 
                `${game.wave} (${Math.floor(game.survivalTime / (60 * 60))}:${Math.floor((game.survivalTime / 60) % 60).toString().padStart(2, '0')})`;
            
            if (game.gameOver) {
                document.getElementById('finalScore').textContent = game.score;
                document.getElementById('gameOver').style.display = 'block';
            }
        }
        
        function restartGame() {
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height / 2;
            game.player.health = game.player.maxHealth;
            game.bullets = [];
            game.enemies = [];
            game.particles = [];
            game.score = 0;
            game.wave = 1;
            game.enemySpawnTimer = 0;
            game.enemySpawnRate = 120;
            game.gameOver = false;
            game.survivalTime = 0;
            game.difficultyMultiplier = 1;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function gameLoop() {
            updateGame();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>