<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: white;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #333;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 200;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            opacity: 0.7;
        }

        #pauseMenu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            min-width: 300px;
        }

        #optionsMenu {
            display: none;
        }

        .menu-button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #333;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            transition: background 0.3s;
        }

        .menu-button:hover {
            background: #444;
        }

        .option-group {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 5px;
        }

        .option-group h3 {
            margin: 0 0 10px 0;
            color: #aaa;
        }

        .color-picker {
            width: 100%;
            height: 30px;
            margin: 5px 0;
            background: none;
            border: none;
            cursor: pointer;
        }

        .shape-select {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
        }

        .resolution-select {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
        }

        .back-button {
            margin-top: 20px;
        }

        #volumeSlider {
            width: 100%;
            margin: 10px 0;
        }

        .option-group input[type="number"] {
            width: 70px;
            padding: 3px;
            margin: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
        }

        #stats {
            position: absolute;
            top: 80px;
            left: 10px;
            font-size: 14px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Health: <span id="health">100</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div id="stats" style="display: none;">
                <div>Damage: <span id="statDamage">1</span></div>
                <div>Speed: <span id="statSpeed">4</span></div>
                <div>Fire Rate: <span id="statFireRate">10</span></div>
            </div>
        </div>
        <div id="gameOver">
            <div>Game Over!</div>
            <div>Final Score: <span id="finalScore">0</span></div>
            <div style="margin-top: 10px; font-size: 16px;">Press SPACE to restart</div>
        </div>
        <div id="instructions">
            WASD: Move | Mouse: Aim | Click: Shoot | SPACE: Restart (when dead) | ESC: Pause
        </div>

        <!-- Pause Menu -->
        <div id="pauseMenu">
            <h2 style="text-align: center; margin-top: 0;">Paused</h2>
            <button class="menu-button" id="resumeButton">Resume</button>
            <button class="menu-button" id="optionsButton">Options</button>
            <button class="menu-button" id="restartButton">Start Over</button>

            <!-- Options Menu -->
            <div id="optionsMenu">
                <div class="option-group">
                    <h3>Colors</h3>
                    <div>Player: <input type="color" id="playerColor" class="color-picker" value="#00ff88"></div>
                    <div>Enemies: <input type="color" id="enemyColor" class="color-picker" value="#ff4444"></div>
                    <div>Obstacles: <input type="color" id="obstacleColor" class="color-picker" value="#555555"></div>
                    <div>Background: <input type="color" id="backgroundColor" class="color-picker" value="#111111"></div>
                </div>

                <div class="option-group">
                    <h3>Shapes</h3>
                    <select id="playerShape" class="shape-select">
                        <option value="circle">Circle</option>
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                    </select>
                    <select id="enemyShape" class="shape-select">
                        <option value="circle">Circle</option>
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </div>

                <div class="option-group">
                    <h3>Resolution</h3>
                    <select id="resolution" class="resolution-select">
                        <option value="800x600">800x600</option>
                        <option value="1024x768">1024x768</option>
                        <option value="1280x720">1280x720</option>
                        <option value="1920x1080">1920x1080</option>
                    </select>
                </div>

                <div class="option-group">
                    <h3>Sound</h3>
                    <input type="range" id="volumeSlider" min="0" max="100" value="50">
                    <div>Volume: <span id="volumeValue">50</span>%</div>
                </div>

                <div class="option-group">
                    <h3>Display</h3>
                    <label>
                        <input type="checkbox" id="showStats" checked> Show Player Stats
                    </label>
                </div>

                <div class="option-group">
                    <h3>Initial Player Stats</h3>
                    <div>Health: <input type="number" id="initialHealth" value="100" min="50" max="200"></div>
                    <div>Speed: <input type="number" id="initialSpeed" value="4" min="2" max="8" step="0.5"></div>
                    <div>Damage: <input type="number" id="initialDamage" value="1" min="0.5" max="5" step="0.5"></div>
                    <div>Fire Rate: <input type="number" id="initialFireRate" value="10" min="5" max="20"></div>
                </div>

                <div class="option-group">
                    <h3>Game Balance</h3>
                    <div>Difficulty Scaling (%/min): <input type="number" id="scaleRate" value="50" min="10" max="100"></div>
                    <div>Item Drop Chance (%): <input type="number" id="dropChance" value="15" min="5" max="50"></div>
                </div>

                <button class="menu-button back-button" id="backButton">Back to Pause Menu</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        const game = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: 12,
                health: 100,
                maxHealth: 100,
                speed: 4,
                angle: 0,
                shootCooldown: 0,
                maxShootCooldown: 10,
                damage: 1,
                damageMultiplier: 1,
                color: '#00ff88',
                shape: 'circle'
            },
            bullets: [],
            enemies: [],
            particles: [],
            items: [],
            score: 0,
            wave: 1,
            enemiesPerWave: 5,
            enemySpawnTimer: 0,
            enemySpawnRate: 120,
            maxEnemies: 15,
            gameOver: false,
            isPaused: false,
            keys: {},
            mouse: { x: 0, y: 0, isDown: false },
            obstacles: [
                { x: 100, y: 100, width: 100, height: 20 },
                { x: 600, y: 400, width: 20, height: 150 },
                { x: 300, y: 300, width: 150, height: 20 },
                { x: 400, y: 100, width: 20, height: 100 }
            ],
            survivalTime: 0,
            difficultyMultiplier: 1,
            settings: {
                enemyColor: '#ff4444',
                enemyShape: 'circle',
                obstacleColor: '#555555',
                backgroundColor: '#111111',
                volume: 50,
                showStats: true,
                initialStats: {
                    health: 100,
                    speed: 4,
                    damage: 1,
                    fireRate: 10
                },
                difficultyScaling: {
                    scaleRate: 0.5, // 50% increase per minute
                    itemDropChance: 0.15 // 15% chance
                }
            }
        };
        
        // Pause menu elements
        const pauseMenu = document.getElementById('pauseMenu');
        const optionsMenu = document.getElementById('optionsMenu');
        const resumeButton = document.getElementById('resumeButton');
        const optionsButton = document.getElementById('optionsButton');
        const restartButton = document.getElementById('restartButton');
        const backButton = document.getElementById('backButton');

        // Options elements
        const playerColor = document.getElementById('playerColor');
        const enemyColor = document.getElementById('enemyColor');
        const obstacleColor = document.getElementById('obstacleColor');
        const backgroundColor = document.getElementById('backgroundColor');
        const playerShape = document.getElementById('playerShape');
        const enemyShape = document.getElementById('enemyShape');
        const resolution = document.getElementById('resolution');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');

        // Event listeners for pause menu
        document.addEventListener('keydown', (e) => {
            game.keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && game.gameOver) {
                restartGame();
            }
            if (e.key === 'Escape') {
                togglePause();
            }
        });

        // Restore the missing input event listeners
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.mouse.x = e.clientX - rect.left;
            game.mouse.y = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            game.mouse.isDown = true;
        });
        
        canvas.addEventListener('mouseup', (e) => {
            game.mouse.isDown = false;
        });
        
        canvas.addEventListener('mouseleave', (e) => {
            game.mouse.isDown = false;
        });

        function togglePause() {
            game.isPaused = !game.isPaused;
            pauseMenu.style.display = game.isPaused ? 'block' : 'none';
            if (!game.isPaused) {
                optionsMenu.style.display = 'none';
            }
        }

        // Menu button listeners
        resumeButton.addEventListener('click', togglePause);
        optionsButton.addEventListener('click', () => {
            pauseMenu.querySelector('h2').style.display = 'none';
            resumeButton.style.display = 'none';
            optionsButton.style.display = 'none';
            restartButton.style.display = 'none';
            optionsMenu.style.display = 'block';
        });
        restartButton.addEventListener('click', () => {
            togglePause();
            restartGame();
        });
        backButton.addEventListener('click', () => {
            pauseMenu.querySelector('h2').style.display = 'block';
            resumeButton.style.display = 'block';
            optionsButton.style.display = 'block';
            restartButton.style.display = 'block';
            optionsMenu.style.display = 'none';
        });

        // Options listeners
        playerColor.addEventListener('input', (e) => {
            game.player.color = e.target.value;
        });

        enemyColor.addEventListener('input', (e) => {
            game.settings.enemyColor = e.target.value;
        });

        obstacleColor.addEventListener('input', (e) => {
            game.settings.obstacleColor = e.target.value;
        });

        backgroundColor.addEventListener('input', (e) => {
            game.settings.backgroundColor = e.target.value;
            // Only change the game background color, not the page background
            document.querySelector('#gameContainer').style.background = e.target.value;
        });

        playerShape.addEventListener('change', (e) => {
            game.player.shape = e.target.value;
        });

        enemyShape.addEventListener('change', (e) => {
            game.settings.enemyShape = e.target.value;
        });

        resolution.addEventListener('change', (e) => {
            const [width, height] = e.target.value.split('x').map(Number);
            canvas.width = width;
            canvas.height = height;
            game.player.x = width / 2;
            game.player.y = height / 2;
        });

        volumeSlider.addEventListener('input', (e) => {
            game.settings.volume = e.target.value;
            volumeValue.textContent = e.target.value;
        });

        // Add event listeners for new options
        document.getElementById('showStats').addEventListener('change', (e) => {
            game.settings.showStats = e.target.checked;
            document.getElementById('stats').style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('initialHealth').addEventListener('change', (e) => {
            game.settings.initialStats.health = Number(e.target.value);
        });

        document.getElementById('initialSpeed').addEventListener('change', (e) => {
            game.settings.initialStats.speed = Number(e.target.value);
        });

        document.getElementById('initialDamage').addEventListener('change', (e) => {
            game.settings.initialStats.damage = Number(e.target.value);
        });

        document.getElementById('initialFireRate').addEventListener('change', (e) => {
            game.settings.initialStats.fireRate = Number(e.target.value);
        });

        document.getElementById('scaleRate').addEventListener('change', (e) => {
            game.settings.difficultyScaling.scaleRate = Number(e.target.value) / 100;
        });

        document.getElementById('dropChance').addEventListener('change', (e) => {
            game.settings.difficultyScaling.itemDropChance = Number(e.target.value) / 100;
        });

        // Game objects
        class Bullet {
            constructor(x, y, angle, speed = 8) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.radius = 3;
                this.life = 100;
            }
            
            update() {
                const newX = this.x + this.vx;
                const newY = this.y + this.vy;

                // Check obstacle collisions
                for (let obstacle of game.obstacles) {
                    if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                        .collidesWith(newX, newY, this.radius)) {
                        return false; // Bullet is destroyed
                    }
                }

                this.x = newX;
                this.y = newY;
                this.life--;
                
                return this.life > 0 && 
                       this.x > -10 && this.x < canvas.width + 10 &&
                       this.y > -10 && this.y < canvas.height + 10;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Item {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = 8;
                this.pulseTime = 0;
                this.collected = false;
            }

            update() {
                // Pulse animation
                this.pulseTime += 0.1;
                const pulseFactor = 1 + Math.sin(this.pulseTime) * 0.2;
                
                // Check if player collected the item
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < this.radius + game.player.radius) {
                    this.collected = true;
                    this.applyEffect();
                }
                
                return !this.collected;
            }

            draw() {
                const pulseFactor = 1 + Math.sin(this.pulseTime) * 0.2;
                ctx.save();
                
                // Different colors and symbols for different power-ups
                switch(this.type) {
                    case 'damage':
                        ctx.fillStyle = '#ff4444';
                        ctx.shadowColor = '#ff0000';
                        break;
                    case 'speed':
                        ctx.fillStyle = '#44ff44';
                        ctx.shadowColor = '#00ff00';
                        break;
                    case 'health':
                        ctx.fillStyle = '#4444ff';
                        ctx.shadowColor = '#0000ff';
                        break;
                    case 'fireRate':
                        ctx.fillStyle = '#ffff44';
                        ctx.shadowColor = '#ffff00';
                        break;
                }
                
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulseFactor, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw symbol
                ctx.fillStyle = 'white';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const symbol = this.type === 'damage' ? '↑' :
                             this.type === 'speed' ? '→' :
                             this.type === 'health' ? '+' : '⚡';
                ctx.fillText(symbol, this.x, this.y);
                
                ctx.restore();
            }

            applyEffect() {
                switch(this.type) {
                    case 'damage':
                        game.player.damageMultiplier += 0.1; // 10% damage increase
                        break;
                    case 'speed':
                        game.player.speed += 0.2; // Small speed boost
                        break;
                    case 'health':
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + 20); // Heal 20 HP
                        break;
                    case 'fireRate':
                        game.player.maxShootCooldown = Math.max(5, game.player.maxShootCooldown - 1); // Decrease cooldown
                        break;
                }
            }
        }
        
        class Enemy {
            constructor() {
                // Spawn from random edge
                const side = Math.floor(Math.random() * 4);
                switch(side) {
                    case 0: // top
                        this.x = Math.random() * canvas.width;
                        this.y = -20;
                        break;
                    case 1: // right
                        this.x = canvas.width + 20;
                        this.y = Math.random() * canvas.height;
                        break;
                    case 2: // bottom
                        this.x = Math.random() * canvas.width;
                        this.y = canvas.height + 20;
                        break;
                    case 3: // left
                        this.x = -20;
                        this.y = Math.random() * canvas.height;
                        break;
                }
                
                // Scale attributes based on survival time with custom scale rate
                const minutes = game.survivalTime / (60 * 60);
                game.difficultyMultiplier = 1 + (minutes * game.settings.difficultyScaling.scaleRate);

                this.radius = 10 + Math.random() * 8;
                this.speed = (1 + Math.random() * 1.5) * (game.difficultyMultiplier * 0.8);
                this.health = Math.ceil((2 + Math.floor(game.wave / 2)) * game.difficultyMultiplier * 1.2);
                this.maxHealth = this.health;
                this.hue = Math.random() * 60 + 300;
            }
            
            update() {
                // Move toward player
                const dx = game.player.x - this.x;
                const dy = game.player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }

                // Check collision with other enemies
                for (let other of game.enemies) {
                    if (other === this) continue;
                    
                    const enemyDx = this.x - other.x;
                    const enemyDy = this.y - other.y;
                    const enemyDist = Math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy);
                    const minDist = this.radius + other.radius;
                    
                    if (enemyDist < minDist && enemyDist > 0) {
                        // Push enemies apart
                        const pushX = (enemyDx / enemyDist) * (minDist - enemyDist) * 0.5;
                        const pushY = (enemyDy / enemyDist) * (minDist - enemyDist) * 0.5;
                        
                        this.x += pushX;
                        this.y += pushY;
                        other.x -= pushX;
                        other.y -= pushY;
                    }
                }

                // Resolve any obstacle collisions that might have occurred
                let attempts = 0;
                const MAX_ATTEMPTS = 3;
                
                while (attempts < MAX_ATTEMPTS) {
                    let hasCollision = false;
                    for (let obstacle of game.obstacles) {
                        if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                            .resolveCollision(this)) {
                            hasCollision = true;
                        }
                    }
                    if (!hasCollision) break;
                    attempts++;
                }
                
                // Check collision with player
                const playerDist = Math.sqrt(
                    (this.x - game.player.x) ** 2 + 
                    (this.y - game.player.y) ** 2
                );
                
                if (playerDist < this.radius + game.player.radius && playerDist > 0) {
                    game.player.health -= 1;
                    if (game.player.health <= 0) {
                        game.gameOver = true;
                    }
                    
                    // Push enemy away slightly
                    const pushX = (this.x - game.player.x) / playerDist;
                    const pushY = (this.y - game.player.y) / playerDist;
                    this.x += pushX * 10;
                    this.y += pushY * 10;
                }
                
                return this.health > 0;
            }
            
            draw() {
                const healthPercent = this.health / this.maxHealth;
                const intensity = 0.3 + healthPercent * 0.7;
                
                ctx.save();
                ctx.fillStyle = game.settings.enemyColor;
                ctx.shadowColor = game.settings.enemyColor;
                ctx.shadowBlur = 8;

                switch(game.settings.enemyShape) {
                    case 'square':
                        ctx.fillRect(this.x - this.radius, this.y - this.radius, 
                                   this.radius * 2, this.radius * 2);
                        break;
                    case 'triangle':
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.radius, this.y);
                        ctx.lineTo(this.x - this.radius, this.y - this.radius);
                        ctx.lineTo(this.x - this.radius, this.y + this.radius);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    default: // circle
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                }
                
                // Health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.radius * 2;
                    const barHeight = 3;
                    const barY = this.y - this.radius - 8;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
                }
                
                ctx.restore();
            }
            
            takeDamage() {
                this.health -= game.player.damageMultiplier;
                if (this.health <= 0) {
                    game.score += 10;
                    createParticles(this.x, this.y, this.hue);
                    
                    // Use custom drop chance
                    if (Math.random() < game.settings.difficultyScaling.itemDropChance) {
                        spawnItem(this.x, this.y);
                    }
                    
                    return true;
                }
                return false;
            }
        }
        
        class Particle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 30 + Math.random() * 20;
                this.maxLife = this.life;
                this.hue = hue;
                this.size = Math.random() * 3 + 1;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            draw() {
                ctx.save();
                ctx.fillStyle = game.settings.obstacleColor;
                ctx.shadowColor = game.settings.obstacleColor;
                ctx.shadowBlur = 5;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.restore();
            }

            collidesWith(x, y, radius) {
                // Find the closest point to the circle within the rectangle
                const closestX = Math.max(this.x, Math.min(x, this.x + this.width));
                const closestY = Math.max(this.y, Math.min(y, this.y + this.height));
                
                // Calculate the distance between the circle's center and this closest point
                const distanceX = x - closestX;
                const distanceY = y - closestY;
                
                // If the distance is less than the circle's radius, an intersection occurs
                const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
                return distanceSquared < (radius * radius);
            }

            resolveCollision(entity) {
                // Find the closest point to the circle within the rectangle
                const closestX = Math.max(this.x, Math.min(entity.x, this.x + this.width));
                const closestY = Math.max(this.y, Math.min(entity.y, this.y + this.height));
                
                // Calculate the distance and direction from the closest point to the circle center
                const dx = entity.x - closestX;
                const dy = entity.y - closestY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < entity.radius && distance > 0) {
                    // Calculate the minimum distance needed to separate the circle from the rectangle
                    const pushDistance = entity.radius - distance;
                    
                    // Normalize the direction and apply the push with a small buffer
                    const pushX = (dx / distance) * (pushDistance + 0.1); // Add small buffer
                    const pushY = (dy / distance) * (pushDistance + 0.1);
                    
                    entity.x += pushX;
                    entity.y += pushY;
                    
                    // Ensure the entity stays within canvas bounds
                    entity.x = Math.min(Math.max(entity.radius, entity.x), canvas.width - entity.radius);
                    entity.y = Math.min(Math.max(entity.radius, entity.y), canvas.height - entity.radius);
                    
                    return true;
                }
                return false;
            }
        }
        
        function createParticles(x, y, hue) {
            for (let i = 0; i < 8; i++) {
                game.particles.push(new Particle(x, y, hue));
            }
        }
        
        function shoot() {
            const angle = Math.atan2(
                game.mouse.y - game.player.y,
                game.mouse.x - game.player.x
            );
            
            game.bullets.push(new Bullet(
                game.player.x + Math.cos(angle) * game.player.radius,
                game.player.y + Math.sin(angle) * game.player.radius,
                angle
            ));
        }
        
        function spawnEnemy() {
            // Only spawn if below max enemies
            if (game.enemies.length < game.maxEnemies) {
                game.enemies.push(new Enemy());
                
                // 40% chance to increase wave when an enemy spawns
                if (Math.random() < 0.4) {
                    game.wave++;
                    // Increase max enemies every 5 waves
                    if (game.wave % 5 === 0) {
                        game.maxEnemies = Math.min(30, game.maxEnemies + 1); // Cap at 30 enemies
                    }
                }
            }
        }
        
        function spawnItem(x, y) {
            const types = ['damage', 'speed', 'health', 'fireRate'];
            const type = types[Math.floor(Math.random() * types.length)];
            game.items.push(new Item(x, y, type));
        }
        
        function updatePlayer() {
            if (game.gameOver || game.isPaused) return;
            
            let newX = game.player.x;
            let newY = game.player.y;

            // Movement
            if (game.keys['w'] || game.keys['arrowup']) {
                newY = game.player.y - game.player.speed;
            }
            if (game.keys['s'] || game.keys['arrowdown']) {
                newY = game.player.y + game.player.speed;
            }
            if (game.keys['a'] || game.keys['arrowleft']) {
                newX = game.player.x - game.player.speed;
            }
            if (game.keys['d'] || game.keys['arrowright']) {
                newX = game.player.x + game.player.speed;
            }

            // Apply movement within canvas bounds
            game.player.x = Math.min(Math.max(game.player.radius, newX), canvas.width - game.player.radius);
            game.player.y = Math.min(Math.max(game.player.radius, newY), canvas.height - game.player.radius);

            // Resolve any obstacle collisions that might have occurred
            let attempts = 0;
            const MAX_ATTEMPTS = 3;
            
            while (attempts < MAX_ATTEMPTS) {
                let hasCollision = false;
                for (let obstacle of game.obstacles) {
                    if (new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height)
                        .resolveCollision(game.player)) {
                        hasCollision = true;
                    }
                }
                if (!hasCollision) break;
                attempts++;
            }
            
            // Aim toward mouse
            game.player.angle = Math.atan2(
                game.mouse.y - game.player.y,
                game.mouse.x - game.player.x
            );
        }
        
        function drawPlayer() {
            ctx.save();
            ctx.translate(game.player.x, game.player.y);
            ctx.rotate(game.player.angle);
            
            ctx.fillStyle = game.gameOver ? '#666' : game.player.color;
            ctx.shadowColor = game.player.color;
            ctx.shadowBlur = 10;

            switch(game.player.shape) {
                case 'square':
                    ctx.fillRect(-game.player.radius, -game.player.radius, 
                               game.player.radius * 2, game.player.radius * 2);
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(game.player.radius * 1.5, 0);
                    ctx.lineTo(-game.player.radius, -game.player.radius);
                    ctx.lineTo(-game.player.radius, game.player.radius);
                    ctx.closePath();
                    ctx.fill();
                    break;
                default: // circle
                    ctx.beginPath();
                    ctx.arc(0, 0, game.player.radius, 0, Math.PI * 2);
                    ctx.fill();
            }
            
            // Gun barrel
            ctx.fillStyle = '#aaa';
            ctx.fillRect(game.player.radius - 2, -2, 15, 4);
            
            ctx.restore();
        }
        
        function updateGame() {
            if (game.gameOver || game.isPaused) return;
            
            // Update survival time and difficulty
            game.survivalTime++;
            
            // Calculate spawn rate based on survival time
            const baseSpawnRate = 120;
            const minutes = game.survivalTime / (60 * 60);
            game.enemySpawnRate = Math.max(20, Math.floor(baseSpawnRate / (game.difficultyMultiplier * 1.2)));

            // Handle continuous shooting
            if (game.mouse.isDown && game.player.shootCooldown <= 0) {
                shoot();
                game.player.shootCooldown = game.player.maxShootCooldown;
            }
            
            // Update shoot cooldown
            if (game.player.shootCooldown > 0) {
                game.player.shootCooldown--;
            }

            // Update items
            game.items = game.items.filter(item => item.update());

            // Spawn enemies
            game.enemySpawnTimer++;
            if (game.enemySpawnTimer >= game.enemySpawnRate) {
                spawnEnemy();
                game.enemySpawnTimer = 0;
            }
            
            // Update bullets
            game.bullets = game.bullets.filter(bullet => {
                const alive = bullet.update();
                
                // Check collision with enemies
                for (let i = game.enemies.length - 1; i >= 0; i--) {
                    const enemy = game.enemies[i];
                    const dist = Math.sqrt(
                        (bullet.x - enemy.x) ** 2 + 
                        (bullet.y - enemy.y) ** 2
                    );
                    
                    if (dist < bullet.radius + enemy.radius) {
                        if (enemy.takeDamage()) {
                            game.enemies.splice(i, 1);
                        }
                        return false; // Remove bullet
                    }
                }
                
                return alive;
            });
            
            // Update enemies
            game.enemies = game.enemies.filter(enemy => enemy.update());
            
            // Update particles
            game.particles = game.particles.filter(particle => particle.update());
            
            updatePlayer();
        }
        
        function draw() {
            // Clear canvas with custom background color, using alpha for trail effect
            ctx.fillStyle = game.settings.backgroundColor + '1A'; // 1A = 10% opacity
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw obstacles
            game.obstacles.forEach(obstacle => {
                new Obstacle(obstacle.x, obstacle.y, obstacle.width, obstacle.height).draw();
            });
            
            // Draw items
            game.items.forEach(item => item.draw());
            
            // Draw particles
            game.particles.forEach(particle => particle.draw());
            
            // Draw bullets
            game.bullets.forEach(bullet => bullet.draw());
            
            // Draw enemies
            game.enemies.forEach(enemy => enemy.draw());
            
            // Draw player
            drawPlayer();
            
            // Update UI
            document.getElementById('score').textContent = game.score;
            document.getElementById('health').textContent = Math.max(0, game.player.health);
            document.getElementById('wave').textContent = 
                `${game.wave} (${Math.floor(game.survivalTime / (60 * 60))}:${Math.floor((game.survivalTime / 60) % 60).toString().padStart(2, '0')}) - ${game.enemies.length}/${game.maxEnemies}`;
            
            if (game.gameOver) {
                document.getElementById('finalScore').textContent = game.score;
                document.getElementById('gameOver').style.display = 'block';
            }

            // Update stats display if enabled
            if (game.settings.showStats) {
                document.getElementById('statDamage').textContent = game.player.damageMultiplier.toFixed(1);
                document.getElementById('statSpeed').textContent = game.player.speed.toFixed(1);
                document.getElementById('statFireRate').textContent = game.player.maxShootCooldown;
            }
        }
        
        function restartGame() {
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height / 2;
            game.player.health = game.settings.initialStats.health;
            game.player.maxHealth = game.settings.initialStats.health;
            game.player.speed = game.settings.initialStats.speed;
            game.player.damage = game.settings.initialStats.damage;
            game.player.damageMultiplier = game.settings.initialStats.damage;
            game.player.maxShootCooldown = game.settings.initialStats.fireRate;
            game.player.color = '#00ff88';
            game.player.shape = 'circle';
            game.bullets = [];
            game.enemies = [];
            game.particles = [];
            game.items = [];
            game.score = 0;
            game.wave = 1;
            game.enemySpawnTimer = 0;
            game.enemySpawnRate = 120;
            game.maxEnemies = 15;
            game.gameOver = false;
            game.survivalTime = 0;
            game.difficultyMultiplier = 1;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        function gameLoop() {
            updateGame();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>